import{_ as i,c as l,o as e,a}from"./app.121accfb.js";const f=JSON.parse('{"title":"http","description":"","frontmatter":{},"headers":[{"level":2,"title":"从浏览器地址栏输入url到请求返回发生了什么？","slug":"从浏览器地址栏输入url到请求返回发生了什么","link":"#从浏览器地址栏输入url到请求返回发生了什么","children":[]},{"level":2,"title":"浏览器的垃圾回收机制","slug":"浏览器的垃圾回收机制","link":"#浏览器的垃圾回收机制","children":[{"level":3,"title":"回收策略","slug":"回收策略","link":"#回收策略","children":[]}]},{"level":2,"title":"http状态码","slug":"http状态码","link":"#http状态码","children":[{"level":3,"title":"分类","slug":"分类","link":"#分类","children":[]},{"level":3,"title":"常见的状态码","slug":"常见的状态码","link":"#常见的状态码","children":[]}]},{"level":2,"title":"http 缓存","slug":"http-缓存","link":"#http-缓存","children":[]}],"relativePath":"interview/browser.md","lastUpdated":1677580297000}'),t={name:"interview/browser.md"},r=a('<h2 id="从浏览器地址栏输入url到请求返回发生了什么" tabindex="-1">从浏览器地址栏输入url到请求返回发生了什么？ <a class="header-anchor" href="#从浏览器地址栏输入url到请求返回发生了什么" aria-hidden="true">#</a></h2><h2 id="浏览器的垃圾回收机制" tabindex="-1">浏览器的垃圾回收机制 <a class="header-anchor" href="#浏览器的垃圾回收机制" aria-hidden="true">#</a></h2><h3 id="回收策略" tabindex="-1">回收策略 <a class="header-anchor" href="#回收策略" aria-hidden="true">#</a></h3><ol><li>标记清除：标记阶段为所有活动对象做上标记，清除阶段则把没有标记销毁</li><li>引用计数：它把<strong>对象是否不再需要</strong>简化定义为<strong>对象有没有其他对象引用到它</strong>。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。</li></ol><h4 id="标记清除的缺点" tabindex="-1">标记清除的缺点 <a class="header-anchor" href="#标记清除的缺点" aria-hidden="true">#</a></h4><ul><li>内存碎片化：空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象找不到合适的块</li><li>分配速度慢，最快也要O(n)</li></ul><p>使用标记整理算法，标记结束后，标记整理算法会将活着的对象，向内存的一端移动，最后清理掉边界的内存。</p><h4 id="引用计数的缺点" tabindex="-1">引用计数的缺点 <a class="header-anchor" href="#引用计数的缺点" aria-hidden="true">#</a></h4><ul><li>需要一个计数器，所<em><strong>占内存空间大</strong></em>，因为我们也不知道被引用数量的上限。</li><li>解决不了<em><strong>循环引用</strong></em>导致的无法回收问题。</li></ul><h1 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-hidden="true">#</a></h1><h2 id="http状态码" tabindex="-1">http状态码 <a class="header-anchor" href="#http状态码" aria-hidden="true">#</a></h2><h3 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-hidden="true">#</a></h3><ul><li>1xx：服务器收到请求</li><li>2xx：请求成功</li><li>3xx：重定向</li><li>4xx：客户端错误</li><li>5xx：服务端错误</li></ul><h3 id="常见的状态码" tabindex="-1">常见的状态码 <a class="header-anchor" href="#常见的状态码" aria-hidden="true">#</a></h3><ul><li>200-成功</li><li>301-永久重定向（配合 location，浏览器自动处理）</li><li>302-临时重定向（配合 location，浏览器自动处理）</li><li>304-资源未被修改</li><li>403-没权限</li><li>404-资源未找到</li><li>500-服务器错误</li><li>504-网关超时</li></ul><h2 id="http-缓存" tabindex="-1">http 缓存 <a class="header-anchor" href="#http-缓存" aria-hidden="true">#</a></h2><h4 id="关于缓存" tabindex="-1">关于缓存 <a class="header-anchor" href="#关于缓存" aria-hidden="true">#</a></h4><p>什么是缓存？ 把一些不需要重新获取的内容再重新获取一次</p><p>为什么需要缓存？ 网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。</p><p>哪些资源可以被缓存？ 静态资源，比如 js css img。</p><h4 id="强制缓存" tabindex="-1">强制缓存 <a class="header-anchor" href="#强制缓存" aria-hidden="true">#</a></h4><p>Cache-Control：</p><ul><li>在 Response Headers 中。</li><li>控制强制缓存的逻辑。</li><li>例如 Cache-Control: max-age=3153600（单位是秒）</li></ul><p>Cache-Control 有哪些值：</p><ul><li>max-age：缓存最大过期时间。</li><li>no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。</li><li>no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。</li></ul><h4 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a></h4><ul><li>服务端缓存策略。</li><li>服务端判断客户端资源，是否和服务端资源一样。</li><li>一致则返回 304，否则返回 200 和最新的资源。</li></ul><p>资源标识：</p><ul><li>在 Response Headers 中，有两种。</li><li>Last-Modified：资源的最后修改时间。</li><li>Etag：资源的唯一标识（一个字符串，类似于人类的指纹）。</li></ul><p><strong>两者比较：</strong></p><ul><li>优先使用 Etag。</li><li>Last-Modified 只能精确到秒级。</li><li>如果资源被重复生成，而内容不变，则 Etag 更精确。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b74c746d1459403382fd0bbc1d96aeca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片 5.png"></p><h4 id="三种刷新操作对http缓存的影响" tabindex="-1">三种刷新操作对http缓存的影响 <a class="header-anchor" href="#三种刷新操作对http缓存的影响" aria-hidden="true">#</a></h4><ul><li><p>正常操作：地址栏输入 url，跳转链接，前进后退等。</p></li><li><p>手动刷新：f5，点击刷新按钮，右键菜单刷新。</p></li><li><p>强制刷新：ctrl + f5，shift+command+r。</p><p><strong>正常操作：强制缓存有效，协商缓存有效。</strong> <strong>手动刷新：强制缓存失效，协商缓存有效。</strong> <strong>强制刷新：强制缓存失效，协商缓存失效。</strong></p></li></ul>',34),h=[r];function n(d,s,o,c,p,u){return e(),l("div",null,h)}const x=i(t,[["render",n]]);export{f as __pageData,x as default};
