## 从浏览器地址栏输入url到请求返回发生了什么？

## 浏览器的垃圾回收机制

### 回收策略

1. 标记清除：标记阶段为所有活动对象做上标记，清除阶段则把没有标记销毁
2. 引用计数：它把**对象是否不再需要**简化定义为**对象有没有其他对象引用到它**。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。

#### 标记清除的缺点

- 内存碎片化：空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象找不到合适的块
- 分配速度慢，最快也要O(n)

使用标记整理算法，标记结束后，标记整理算法会将活着的对象，向内存的一端移动，最后清理掉边界的内存。

#### 引用计数的缺点

- 需要一个计数器，所***占内存空间大***，因为我们也不知道被引用数量的上限。
- 解决不了***循环引用***导致的无法回收问题。



# http

## http状态码

### 分类

- 1xx：服务器收到请求
- 2xx：请求成功
- 3xx：重定向
- 4xx：客户端错误
- 5xx：服务端错误

### 常见的状态码

- 200-成功
- 301-永久重定向（配合 location，浏览器自动处理）
- 302-临时重定向（配合 location，浏览器自动处理）
- 304-资源未被修改
- 403-没权限
- 404-资源未找到
- 500-服务器错误
- 504-网关超时

## http 缓存

#### 关于缓存

什么是缓存？ 把一些不需要重新获取的内容再重新获取一次

为什么需要缓存？ 网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。

哪些资源可以被缓存？ 静态资源，比如 js css img。

#### 强制缓存

Cache-Control：

- 在 Response Headers 中。
- 控制强制缓存的逻辑。
- 例如 Cache-Control: max-age=3153600（单位是秒）

Cache-Control 有哪些值：

- max-age：缓存最大过期时间。
- no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。
- no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。

#### 协商缓存

- 服务端缓存策略。
- 服务端判断客户端资源，是否和服务端资源一样。
- 一致则返回 304，否则返回 200 和最新的资源。

资源标识：

- 在 Response Headers 中，有两种。
- Last-Modified：资源的最后修改时间。
- Etag：资源的唯一标识（一个字符串，类似于人类的指纹）。

**两者比较：**

- 优先使用 Etag。
- Last-Modified 只能精确到秒级。
- 如果资源被重复生成，而内容不变，则 Etag 更精确。

![图片 5.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b74c746d1459403382fd0bbc1d96aeca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

#### 三种刷新操作对http缓存的影响

- 正常操作：地址栏输入 url，跳转链接，前进后退等。

- 手动刷新：f5，点击刷新按钮，右键菜单刷新。

- 强制刷新：ctrl + f5，shift+command+r。

  **正常操作：强制缓存有效，协商缓存有效。** **手动刷新：强制缓存失效，协商缓存有效。** **强制刷新：强制缓存失效，协商缓存失效。**

